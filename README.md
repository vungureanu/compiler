To specify a context-free grammar, one provides a finite set of rules of the form V -> S_1...S_n, where V is a variable and each S_i is either a variable or a terminal.  This section explains how such rules are represented by the program.

Variables and terminals:

Variables are represented by members of the class `Token`, while terminals are represented by strings.  (We denote by `T(S)` the representation of the variable or string S.)  There are two sorts of variales: those that are defined by the user in specifying the grammar, and those that are created by the program when user-defined rules are converted to Chomsky normal form.  These latter variables may be added in two cases: if there exists a terminal `t`, and if there exists a rule V -> S_1...S_n, where n >= 3.  In the first case, the variable V_t is added alongside the rule V_t -> t.  In the second case, the variable V_{S_2...S_n} is added alongside the rule V_{S_2...S_n} -> S_2...S_n.  In this case, the list `[T(S_2), ..., T(S_n)]` is the `expansion` of `T(V_{S_2...S_n})`.

Rules:

The rule Ru = A -> B_1...B_n, where each B_i is a variable or terminal, is represented by the member of the class `Rule` for which `lhs` is `T(A)` and `rhs` is `[T(B_1), ..., T(B_n)]`.  (We denote by `R(Ru)` the representation of Ru.)  Expressions of the context-free grammar may be meaningful; to allow for semantic operations on such expressions, an optional `evaluation` may be provided, which allows each such expression to have several possible values.  This is accomplished by endowing each terminal with a value, and allowing the possible values of B_1...B_n to follow from the possible values of B_1, ..., B_n.  If A -> t is a rule, its `evaluation` is a function f from strings to values such that the value of t is f(t).  If A -> B_1...B_n is a rule, its `evaluation` is a function f from n values to a value such that the value of `T(A)` is `f(T(B_1), ..., T(B_n))`.

Parse trees:

Various parse trees may be constructed given a context-free grammar and a sequence of terminals.  A tree is valid if its leaves are labeled (in order) by the sequence of terminals, its non-leaf nodes are labeled by variables, its root is labeled <start>, and if a node labeled A has children labeled B_1, ..., B_n (in that order), then A -> B_1...B_n is a rule of the context-free grammar.  Members of `Parse_Node` correspond to leaves of such a tree.  A node labeled A with child labeled t corresponds to a `Parse_Node` for which `lhs` is `T(A)`, `rhs` is `[t]`, and `rule` is `R(A -> t)`.  A node labeled A with children B_1...B_n corresponds to a `Parse_Node` for which `lhs` is `T(A)`, `rhs` is `[C_1, ..., C_n]` (where `C_1` is the `Parse_Node` corresponding to the node's ith child), and `rule` is `A -> B_1...B_n`.
